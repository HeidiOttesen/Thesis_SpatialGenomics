---
title: "Human DNA Colon"
output: html_document
---

## Preface
Set working directory for the entire markdown/notebook. - doesn't work - still need to specify path
Load packages needed

```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/")
knitr::opts_chunk$set(echo = TRUE)
library(vesalius)
library(imagerExtra)
library(Seurat)
library(ggplot2)
library(patchwork)
library(viridis)
library(RColorBrewer)
library(dplyr)
library(tvR)
library(sp)
library(grid)
library(Matrix)


# Standard libraries - just in case you are a command line fiend
library(utils)
library(stats)
library(graphics)
library(grDevices)
### Set seed
set.seed(1)
```


## Read data from files
and create a sparse count matrix. (mostly 0's, bins as columns and barcodes as rows? )


```{r}
#alias <- "human_colon_cancer_4_dna_200114_13"
#counts <- "~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/human_colon_cancer_4_dna_200114_13.sparse_counts_1Mb.txt"
#bead <- ReadSlideSeq("~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/human_colon_cancer_4_dna_200114_13.bead_locations.csv")


#alias <- "human_colon_cancer_3_dna_191204_19"
#counts <- "~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/human_colon_cancer_3_dna_191204_19.sparse_counts_1Mb.txt"
#bead <- ReadSlideSeq("~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/human_colon_cancer_3_dna_191204_19.bead_locations.csv")

# Mouse liver sparse count already holds 
alias <- "mouse_liver_met_2_dna_200114_10"
counts <- "~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/mouse_liver_met_2_dna_200114_10.sparse_counts_1Mb.txt"
bead <- ReadSlideSeq("~/Thesis_SpatialGenomics/SlideSeq/SlideSeq_ves_test/mouse_liver_met_2_dna_200114_10.bead_locations.csv")



#Collect the 1000s of barcode sequences from the bead locations file
barcodes <- rownames(bead@coordinates)

#separator used in this count matrix
sep = "\t"
ctmp <- read.table(counts, header = TRUE, sep=sep ) %>% na.exclude()
# Create DG matrix: i + j - row and column index - maybe a mix of row and columns - do as.counts instead
sparse <- sparseMatrix(i= ctmp[,2],j=ctmp[,1],x=ctmp[,3]) 

#Curious about the count distribution values
max <- sort(sparse@x, decreasing = TRUE)
hist(max)
#axis(side=1, at=seq(0,100, 10), labels=seq(0,1000,100))


# invert/transpose/switch between rows and columns
#sparse <- t(sparse)

```


## Run this chunk for human samples:
Each bin index corresponds to 1million bases in a specific location on a chromosome.
```{r}
# human bins - bin size: 1 million bases, index 1 = chromosome 1 from base 1 -> 1.000.000. Chr2 starts at bin 251 :
hbins <- read.table("~/Thesis_SpatialGenomics/SlideSeq/GroupSlideSeq/hg19_1Mb_bins.txt", header = T)
# Keep only the bin index numbers (1-3114. ~3.1bn bases)
hbins <- hbins$bin_ind
```


## Run this chunk for mouse
2738 bins total of 1mill bases
```{r}
mmbins <- read.table("~/Thesis_SpatialGenomics/SlideSeq/GroupSlideSeq/mm10_1Mb_bins.txt", header = T)
mmbins <- mmbins$bin_ind
```


## Name column/rows in sparse matrix
Assign bin index numbers to identify the rows. 
Assign the barcodes to identify the columns


```{r}

colnames(sparse) <- barcodes
#Mouse bins:
rownames(sparse) <- mmbins

#Human bins:
#rownames(sparse) <- hbins
```

## Create Seurat Object - Milestone
Insert the Barcode sequences in the bead vector?

```{r}
ctmp.SO <- CreateSeuratObject(sparse, assay ="Spatial")

#I don't understand how this part works
bead <- bead[Cells(x = ctmp.SO)]
DefaultAssay(object = bead) <- "Spatial"
ctmp.SO[["slice1"]] <- bead
```


## Normalize / Find Features / Scale
Either by Seurats functions or using SCTransform or not at all
Do this make sense to do on the DNA data? 

```{r}



#norm <- "seuratNorm"
#ctmp.norm <- NormalizeData(ctmp.SO)


norm <- "SCTransform"
ctmp.sct <- SCTransform(ctmp.SO, assay = "Spatial", verbose = FALSE)


#norm <- "No_norm"



#Pick ctmp.sct or ctmp.norm or ctmp.SO
ctmp <- FindVariableFeatures(ctmp.sct, nfeatures = 2000)


ctmp <- ScaleData(ctmp)



```

## Create image plotting function - coloured and grayscale

```{r}
## This is equal to the existing function imagePlot except This can include Title

cimg.plot <- function(image, step) {
  ss <- subset(image, select=c(x, y, cc, value))
#  layout(matrix(1, 2))
  g <- as.cimg(ss) %>% plot(main=c(step, "Array (as.cimg)"))
#  g <- grayscale(g) %>% plot(main =c(step, "Grayscale"))
}

```

## Dimensionality Reduction
Latent space
PCA / UMAP / tSNE (/Semantic Ves Dev?)

```{r}
#Test different number of slices
dimred <- "PCA_3slices"
ctmp.pca <- rgbPCA(ctmp, slices = 3 , conserveSparse = FALSE)

#test rgbUMAP as well!
#dimred <- "UMAP_30pcs"
#ctmp.umap <- rgbUMAP(SO = ctmp.pca, conserveSparse=F)
#ctmp.umap <- rgbUMAP(SO = ctmp, conserveSparse=F)
#count <- rgbUMAP(count, pcs =30, conserveSparse = FALSE)
#countList[[i]] <- count



  #### Remember no split ! all in the same file!!!!!
#exportRGB.csv(ctmp,file = paste0(alias,"_rgbExport.csv"),split=F)
```



#Image processing: - Milestone - Image array

Time consuming! (10mins - 1Gb Seurat)
Try reducing resolution to 10% - for the trial

```{r}

image <- buildImageArray(ctmp.pca,filterThreshold=0.9975,resolution=20, cores=5)

#Keep a copy before messing up the rest
image.array <- image

```





```{r}
image <- equalizeHistogram(image.array, sleft = 2.5, sright=2.5,invert =T)
image <- regulariseImage(image, lambda = 10, niter = 200, normalise=T)

image <- iterativeSegmentation.array(image, colDepth = 6,
                                            smoothIter = 20, method = c("iso","median"), sigma=1.5,box = 10, useCenter = T)

image <- isolateTerritories.array(image, captureRadius = 0.008, minBar = 40)
```

## Publish plots in pdf
DNA - Very gray with a hint of green?

```{r}
now <- Sys.time()
fname <- paste(format(now, "%Y%m%d_%H%M%S"), alias, norm, dimred, "images.pdf", sep="_")
pdf(fname)
layout(matrix(c(1,3,2,4), 2, 2))

cimg.plot(image.array, 'Original')


cimg.plot(image, 'Isolated Territories')

territoryPlot(image,cex=10)

dev.off()
```


```{r}

#write.csv(image, file = paste0(alias,"_ImageExport.csv"))
```

